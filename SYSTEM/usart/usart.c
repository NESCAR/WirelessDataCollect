/**
  ******************************************************************************
  * @file    usart.c
  * @author  zju.nesc.iotlab    浙江大学NeSC课题组物联网实验室
  * @version V1.0
  * @date    8-April-2019
  * @brief   usart function   串口函数
  ******************************************************************************
  */

//-------------include---------------//
#include "sys.h"
#include "usart.h"
#include "config.h"

/* 支持printf输出到串口*/  
#if 1
#pragma import(__use_no_semihosting)                            
struct __FILE 
{ 
	int handle; 
}; 
FILE __stdout;       
int fputc(int ch, FILE *f)
{ 	
	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
	USART1->DR = (u8) ch;      
	return ch;
}
#endif
/* 如果使能了接收*/
#if EN_USART1_RX    
//! 接收命令的缓存器
CMD_QUEUE CMD_RX_BUF = {.CmdCompleteFlag = CMD_NOT_COMPLETED,.head = 0,.tail = 0};     

/**
  * @brief  串口初始化
  * @param  bound：波特率
  * @retval None
  */
void uart_init(u32 bound){
	//GPIO端口设置
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);     //使能GPIOA时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);    //使能USART1时钟

	/* 串口1对应引脚复用映射*/
	GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1);  //GPIOA9复用为USART1
	GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1); //GPIOA10复用为USART1

	/* USART1端口配置*/
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10; //GPIOA9与GPIOA10
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            //复用功能
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	      //速度50MHz
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;          //推挽复用输出
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;            //上拉
	GPIO_Init(GPIOA,&GPIO_InitStructure);                   //初始化PA9，PA10

	/* USART1 初始化设置*/
	USART_InitStructure.USART_BaudRate = bound;                                          //波特率设置
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;                          //字长为8位数据格式
	USART_InitStructure.USART_StopBits = USART_StopBits_1;                               //一个停止位
	USART_InitStructure.USART_Parity = USART_Parity_No;                                  //无奇偶校验位
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;      //无硬件数据流控制
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	                     //收发模式
	USART_Init(USART1, &USART_InitStructure);                                            //初始化串口1

	USART_Cmd(USART1, ENABLE);                                                           //使能串口1 

	/* 使能串口接收*/
	#if EN_USART1_RX	
		USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);              //开启相关中断

		NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;           //串口1中断通道
		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3;     //抢占优先级3
		NVIC_InitStructure.NVIC_IRQChannelSubPriority =3;		        //子优先级3
		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			        //IRQ通道使能
		NVIC_Init(&NVIC_InitStructure);	                            //根据指定的参数初始化VIC寄存器、

	#endif
	
}

/**
  * @brief  串口中断服务函数
  * @param  None
  * @retval None
  */
void USART1_IRQHandler(void)
{
	static u8 ResLast;
	u8 Res;
	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
	{
		Res = USART1->DR;
		if(CMD_RX_BUF.CmdCompleteFlag == CMD_NOT_COMPLETED)  //一次只能处理一条指令
		{
			if(Res == '\n' && ResLast == '\r')//一条指令完成了
			{
				CMD_RX_BUF.CmdCompleteFlag=CMD_COMPLETED;
			}
			uart_queue_put(&CMD_RX_BUF,Res);			
		}
		
		ResLast = Res;

    }
}
#endif	

/**
  * @brief  put串口数据队列
  * @param  pQueue：目标队列
  * @param  ch：要加入的字符
  * @retval None
  */
void uart_queue_put(volatile CMD_QUEUE * pQueue, u8 ch)
{
    pQueue->buff[pQueue->tail] = ch;
	pQueue->tail = (pQueue->tail + 1) % USART_REC_LEN;
}

/**
  * @brief  put多个串口数据队列
  * @param  pQueue：目标队列
  * @param  ch：要加入的首个字符地址
  * @param  len：要加入的字符长度
  * @retval None
  */
void uart_queue_put_many(volatile CMD_QUEUE * pQueue, u8 * ch,u16 len)
{
	for(u16 i=0;i<len;i++){;
		 uart_queue_put(pQueue,*(ch+i));
	}
}

/**
  * @brief  数据出队列
  * @param  pQueue：目标队列
  * @retval None
  */
u8 uart_queue_pop(volatile CMD_QUEUE * pQueue)
{
    u8 data = pQueue->buff[pQueue->head];
    pQueue->head = (pQueue->head + 1) % USART_REC_LEN;
    return data;
}

/**
  * @brief  获取队列的长度
  * @param  pQueue：目标队列
  * @retval 队列的长度
  */
u16 uart_queue_length(volatile CMD_QUEUE * pQueue)
{
	return (pQueue->tail-pQueue->head+USART_REC_LEN)%USART_REC_LEN;
}

/**
  * @brief  清空队列
  * @param  pQueue：目标队列
  * @retval None
  */
void uart_queue_clear(volatile CMD_QUEUE * pQueue)
{
	pQueue->CmdCompleteFlag = CMD_NOT_COMPLETED;
	pQueue->head = pQueue->tail;
}
